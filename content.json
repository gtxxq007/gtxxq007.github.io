[{"title":"AOP的总结","date":"2020-05-31T12:42:17.000Z","path":"2020/05/31/AOP的总结/","text":"&nbsp; &nbsp;前些时间有学习Spring AOP相关的知识，但是时间久了就会忘记，打算有时间总结归纳一下，方便记忆和书写。 AOP的概述AOP 是什么？&nbsp; &nbsp;AOP（Aspect Orient Programming）是一种设计思想，是软件设计领域中的面向切面编程，它是面向对象编程(OOP)的一种补充和完善。它以通过预编译方式和运行期动态代理方式，实现在不修改源代码的情况下给程序动态统一添加额外功能的一种技术。AOP 相关术语分析&nbsp; &nbsp;1.切面(aspect):横切面对象，一遍为一个具体类对象(可以借助注解@Aspect声明)&nbsp; &nbsp;2.通知(Advice):在切面的某个特定的点，一般值被拦截的方法&nbsp; &nbsp;3.连接点(joinpoint):程序执行过程中某个特定的点，一般指被拦截的方法。&nbsp; &nbsp;4.切入点(pointcut):对多个连接点(joinpoint)一种定义，一般可以理解为多个连接点的集合 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374@Component@Aspectpublic class SysTimeAspect &#123; @Pointcut(\"bean(sysUserServiceImpl)\") public void doTime()&#123;&#125; @Before(\"doTime()\") public void doBefore(JoinPoint jp)&#123; System.out.println(\"time doBefore()\"); &#125; @After(\"doTime()\") public void doAfter()&#123; System.out.println(\"time doAfter()\"); &#125; /**核心业务正常结束时执行* 说明：假如有after，先执行after,再执行returning*/ @AfterReturning(\"doTime()\") public void doAfterReturning()&#123; System.out.println(\"time doAfterReturning\"); &#125; /**核心业务出现异常时执行说明：假如有after，先执行after,再执行Throwing*/ @AfterThrowing(\"doTime()\") public void doAfterThrowing()&#123; System.out.println(\"time doAfterThrowing\"); &#125; @Around(\"doTime()\") public Object doAround(ProceedingJoinPoint jp) throws Throwable&#123; System.out.println(\"doAround.before\"); try&#123; Object obj=jp.proceed(); System.out.println(\"doAround.after\"); &#125;catch(Throwable e)&#123; System.out.println(e.getMessage()); throw e; &#125; return obj; &#125;&#125; 说明：对于@AfterThrowing通知只有在出现异常时才会执行，所以当做一些异常监控时，可以在此方法中进行代码实现。 AOP 的切入点表达式 Spring中通过切入点表达式定义具体切入点，其中常用AOP切入点表达式定义以及说明： 1.bean表达式(较重点)作用:用于匹配指定bean对象的所有方法 bean表达式一般应用于类级别，实现粗粒度的切入点的定义。 bean(“userServiceImpl”)指定一个userServiceImpl类中的所有方法 bean(“*ServiceImpl”)指定所有后缀为ServiceImpl的类中的所有方法 说明：bean表达式内部的对象是由spring容器管理的一个bean对象，表达式内部的名字应该式spring容器中某个bean的name。 2.within表达式(熟悉)作用:用于匹配指定报下所有类内的所有方法 within表达式应用于类级别，实现粗粒度的切入点表达式定义。 within(“aop.service.UserServiceImpl”)指定当前包中这个类内部的所有方法 within(“aop.service.*”)指顶目录下的所有类的所有方法 within(“aop.service..*”)指当前目录以及子目录中类的所有方法 3.execution表达式(较重点)作用:用于按指定语法规则匹配到具体方法execution表达式应用于方法级别，实现细粒度的切入点表达式定义，案例分析语法：execution(返回值 包名.类名.方法名(参数列表))。 execution(void.aop.service.UserServiceImpl.addUser())匹配addUser方法。 execution(void aop.service.PersonServiceImpl.addUser(String))方法参数必须为String的addUser方法。 execution(* aop.service...(..)) 万能配置 4.@annotation表达式（重点）作用：用于匹配指定注解修饰的方法@annotaion表达式应用于方法级别，实现细粒度的切入点表达式 @annotation(anno.RequiredLog)匹配由此注解的方法。 @annotatiom(anno.RequireCache)匹配由此注解描述的方法 其中：RequiredLog为我们自己定义的注解，当我们是同@RequiredLong注解修饰业务层方法时，系统底层会在执行此方法时进行扩展操作。 代码如下所示第一步：定义注解RequiredCache 1234567891011121314151617package com.cy.pj.common.annotation;/** * 自定义注解,一个特殊的类,所有注解都默认继承Annotation接口 */@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface RequiredCache &#123; //...&#125; 第二步：定义SysCahcheAspect切面对象。 123456789101112131415161718192021222324252627package com.cy.pj.common.aspect;@Aspect@Componentpublic class SysCacheAspect &#123; @Pointcut(\"@annotation(com.cy.pj.common.annotation.RequiredCache)\") public void doCache() &#123;&#125; @Around(\"doCache()\") public Object around(ProceedingJoinPoint jp)throws Throwable&#123; System.out.println(\"Get data from cache\"); Object obj=jp.proceed(); System.out.println(\"Put data to cache\"); return obj; &#125;&#125; 第三步：使用@RequiredCache注解对特定业务目标对象中的查询方法进行描述 1234567891011@RequiredCache @Override public List&lt;Map&lt;String, Object&gt;&gt; findObjects() &#123; …. return list; &#125; 切面的优先级设置实现切面的优先级需要借助@Order注解进行描述，数字越小哟遇险记越高，默认优先级较低，例如，如下代码定义日志切面指定优先级 1234567891011@Order(1)@Aspect@Componentpublic class SysLogAspect &#123; …&#125; 定义缓存切面并指定优先级： 1234567891011@Order(2)@Aspect@Componentpublic class SysCacheAspect &#123; …&#125; Spring 中事务管理","comments":true,"categories":[],"tags":[{"name":"AOP","slug":"AOP","permalink":"http://yoursite.com/tags/AOP/"},{"name":"总结","slug":"总结","permalink":"http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"restFul风格","date":"2020-05-24T11:17:08.299Z","path":"2020/05/24/restful风格/","text":"&nbsp; &nbsp;最近重新学习了springBoot相关的知识，再一次接触到restFul风格编写代码的方法式，以前就觉得很牛叉，但是知识知道却不知道叫什么名字，今天有机会来总结一下。 介绍&nbsp; &nbsp;RESTFUL是一种网络应用程序的设计风格和开发方式，基于HTTP，可以使用XML格式定义或JSON格式定义。RESTFUL适用于移动互联网厂商作为业务使能接口的场景，实现第三方OTT调用移动网络资源的功能，动作类型为新增、变更、删除所调用资源。REST（英文：Representational State Transfer，简称REST）描述了一个架构样式的网络系统，比如web应用程序。它首次出现在2000年Roy Fielding的博士论文中，Roy Fielding是HTTP规范的主要编写者之一。在目前主流的三种Web服务交互方案中，REST相比于SOAP（Simple Object Access protocol，简单对象访问协议）以及XML-RPC更加简单明了，无论是对URL的处理还是对Payload的编码，REST都倾向于用更加简单轻量的方法设计和实现。假设某个使用传统方式设计的请求路径及所需的参数是： 1/addresses/set_default?aid=10 使用REST风格，可以设计为： 1/addresses/10/set_default 后台的请求处理 123@RequestMapping(\"&#123;aid&#125;/delete\")public JsonResult&lt;Void&gt; delete( @PathVariable(\"aid\") Integer aid, HttpSession session) &#123;...&#125; 使用restFul风格1:如下所示的请求的路径： 123&lt;li data-options=\"attributes:&#123;'url':'/page/item-add'&#125;\"&gt;新增商品&lt;/li&gt;&lt;li data-options=\"attributes:&#123;'url':'/page/item-list'&#125;\"&gt;查询商品&lt;/li&gt;&lt;li data-options=\"attributes:&#123;'url':'/page/item-param-list'&#125;\"&gt;规格参数&lt;/li&gt; 以上方式的请求路径有很多的共同的特点，可以使用restFul风格进行统一的页面跳转： 12345@RequestMapping(\"/page/&#123;moduleName&#125;\") public String module(@PathVariable String moduleName) &#123; return moduleName; &#125; 在使用restFul风格时一定要遵循restFul风格的语法：​ 1.参数必学使用/方式进行分割​ 2.参数必须使用{}包裹，名称任意，简明知意即可​ 3.在方法中添加同名的参数 + 注解 @PathVariable @PathVariable注解说明： 1.value/name如果参数命名和方法中的参数名称不一致的时候，则使用value或者name进行转换 2.required() default true 该值为必传数据。restFul风格2: 用法:根据不同的请求类型实现不同的业务功能 需求: /user/addUser 新增用户 /user/deleteUser?id=xx 删除用户 /user/updateUser?xxx 更新用户 /user/getUser?id=1 查询用户 页面中url地址使用 url: /user 可以自动的实现CRUD操作。 123456789101112131415161718//1.新增为例 //@RequestMapping(value = \"/user\",method = RequestMethod.POST) * * @PostMapping(\"/user\") public XXXXX saveUser(User user) &#123; * * &#125; * * //2.查询用户 * * @GetMapping(\"/user\") * * @PutMapping(\"/user\") * * @DeleteMapping(\"/user\") public XXXXX getUser(Integer id) &#123; * * return xxx; &#125; */ &#125; 总结&nbsp; &nbsp;1.可以动态的获取url中的参数。&nbsp; &nbsp;2.可以根据不同的请求参数，实现不同的业务操作。 本片内容大部分来自于成恒老师和刘昱江老师分享的笔记内容，再次感谢以上两位老师","comments":true,"categories":[],"tags":[{"name":"总结","slug":"总结","permalink":"http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"},{"name":"restFul","slug":"restFul","permalink":"http://yoursite.com/tags/restFul/"}]},{"title":"数据库的隔离级别和传播特性","date":"2020-05-10T16:37:11.000Z","path":"2020/05/11/数据库的隔离级别和传播特性/","text":"","comments":true,"categories":[],"tags":[]},{"title":"let和var区别","date":"2020-05-04T13:31:39.000Z","path":"2020/05/04/let和var区别/","text":"第一次写博客，也是花了很长时间搭建的，感觉自豪感爆棚。&nbsp; &nbsp;做为开篇的第一篇博客，博主的能力也很有限，今天就主要来讲一下let和var的区别。 &nbsp; &nbsp;首先let和var都时javascript语言中的关键字，但是let是ECMAScript 6中的一个新的命令，也是用来声明变量。&nbsp; &nbsp;第二点，let不能重复声明，但是var可以。首先那打开我们的浏览器按下F12打开控制台，我这边使用的是谷歌浏览器。 首先是用var声明变量其次是用let声明的变量很明显当我们使用var的时候时刻以反复声明同一个变量的，但是当我们使用let时会出现一个错误Uncaught SyntaxError: Identifier ‘b’ has already been declared，未捕获的SyntaxError:标识符“b”已经声明。&nbsp;&nbsp;第三点，var是全局作用的作用域，而let只有在自己声明的作用域内才有效。请看如下代码：域问题for循环问题&nbsp;&nbsp;第四，let不存在变量提升变量提升可以说是var声明设计不严谨的一点，可能我们在开发中已经习惯声明一个全局变量，然后可以在声明前后都可以使用它，这很方便，但是不符合规范。代码如下：接下来是var：很明显我能看出二者之间的不同！&nbsp;&nbsp;最后let存在暂时性死域，当一个区域存在let声明时，这个区域就形成了一个封闭的作用域，在let声明前使用这个变量就会报错，也就是只能先声明再使用，这种语法也称为暂时性死域。如下代码：本文多数转自于该博客https://www.cnblogs.com/echolun/p/10575676.html谢谢观看","comments":true,"categories":[],"tags":[]},{"title":"Hello World","date":"2020-05-03T16:12:12.115Z","path":"2020/05/04/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","comments":true,"categories":[],"tags":[]}]