[{"title":"restFul风格","date":"2020-05-24T11:17:08.299Z","path":"2020/05/24/restful风格/","text":"&nbsp; &nbsp;最近重新学习了springBoot相关的知识，再一次接触到restFul风格编写代码的方法式，以前就觉得很牛叉，但是知识知道却不知道叫什么名字，今天有机会来总结一下。 介绍&nbsp; &nbsp;RESTFUL是一种网络应用程序的设计风格和开发方式，基于HTTP，可以使用XML格式定义或JSON格式定义。RESTFUL适用于移动互联网厂商作为业务使能接口的场景，实现第三方OTT调用移动网络资源的功能，动作类型为新增、变更、删除所调用资源。REST（英文：Representational State Transfer，简称REST）描述了一个架构样式的网络系统，比如web应用程序。它首次出现在2000年Roy Fielding的博士论文中，Roy Fielding是HTTP规范的主要编写者之一。在目前主流的三种Web服务交互方案中，REST相比于SOAP（Simple Object Access protocol，简单对象访问协议）以及XML-RPC更加简单明了，无论是对URL的处理还是对Payload的编码，REST都倾向于用更加简单轻量的方法设计和实现。假设某个使用传统方式设计的请求路径及所需的参数是： 1/addresses/set_default?aid=10 使用REST风格，可以设计为： 1/addresses/10/set_default 后台的请求处理 123@RequestMapping(\"&#123;aid&#125;/delete\")public JsonResult&lt;Void&gt; delete( @PathVariable(\"aid\") Integer aid, HttpSession session) &#123;...&#125; 使用restFul风格1:如下所示的请求的路径： 123&lt;li data-options=\"attributes:&#123;'url':'/page/item-add'&#125;\"&gt;新增商品&lt;/li&gt;&lt;li data-options=\"attributes:&#123;'url':'/page/item-list'&#125;\"&gt;查询商品&lt;/li&gt;&lt;li data-options=\"attributes:&#123;'url':'/page/item-param-list'&#125;\"&gt;规格参数&lt;/li&gt; 以上方式的请求路径有很多的共同的特点，可以使用restFul风格进行统一的页面跳转： 12345@RequestMapping(\"/page/&#123;moduleName&#125;\") public String module(@PathVariable String moduleName) &#123; return moduleName; &#125; 在使用restFul风格时一定要遵循restFul风格的语法：​ 1.参数必学使用/方式进行分割​ 2.参数必须使用{}包裹，名称任意，简明知意即可​ 3.在方法中添加同名的参数 + 注解 @PathVariable @PathVariable注解说明： 1.value/name如果参数命名和方法中的参数名称不一致的时候，则使用value或者name进行转换 2.required() default true 该值为必传数据。restFul风格2: 用法:根据不同的请求类型实现不同的业务功能 需求: /user/addUser 新增用户 /user/deleteUser?id=xx 删除用户 /user/updateUser?xxx 更新用户 /user/getUser?id=1 查询用户 页面中url地址使用 url: /user 可以自动的实现CRUD操作。 123456789101112131415161718//1.新增为例 //@RequestMapping(value = \"/user\",method = RequestMethod.POST) * * @PostMapping(\"/user\") public XXXXX saveUser(User user) &#123; * * &#125; * * //2.查询用户 * * @GetMapping(\"/user\") * * @PutMapping(\"/user\") * * @DeleteMapping(\"/user\") public XXXXX getUser(Integer id) &#123; * * return xxx; &#125; */ &#125; 总结&nbsp; &nbsp;1.可以动态的获取url中的参数。&nbsp; &nbsp;2.可以根据不同的请求参数，实现不同的业务操作。 本片内容大部分来自于成恒老师和刘昱江老师分享的笔记内容，再次感谢以上两位老师","comments":true,"categories":[],"tags":[{"name":"-总结","slug":"总结","permalink":"http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"数据库的隔离级别和传播特性","date":"2020-05-10T16:37:11.000Z","path":"2020/05/11/数据库的隔离级别和传播特性/","text":"","comments":true,"categories":[],"tags":[]},{"title":"let和var区别","date":"2020-05-04T13:31:39.000Z","path":"2020/05/04/let和var区别/","text":"第一次写博客，也是花了很长时间搭建的，感觉自豪感爆棚。&nbsp; &nbsp;做为开篇的第一篇博客，博主的能力也很有限，今天就主要来讲一下let和var的区别。 &nbsp; &nbsp;首先let和var都时javascript语言中的关键字，但是let是ECMAScript 6中的一个新的命令，也是用来声明变量。&nbsp; &nbsp;第二点，let不能重复声明，但是var可以。首先那打开我们的浏览器按下F12打开控制台，我这边使用的是谷歌浏览器。 首先是用var声明变量其次是用let声明的变量很明显当我们使用var的时候时刻以反复声明同一个变量的，但是当我们使用let时会出现一个错误Uncaught SyntaxError: Identifier ‘b’ has already been declared，未捕获的SyntaxError:标识符“b”已经声明。&nbsp;&nbsp;第三点，var是全局作用的作用域，而let只有在自己声明的作用域内才有效。请看如下代码：域问题for循环问题&nbsp;&nbsp;第四，let不存在变量提升变量提升可以说是var声明设计不严谨的一点，可能我们在开发中已经习惯声明一个全局变量，然后可以在声明前后都可以使用它，这很方便，但是不符合规范。代码如下：接下来是var：很明显我能看出二者之间的不同！&nbsp;&nbsp;最后let存在暂时性死域，当一个区域存在let声明时，这个区域就形成了一个封闭的作用域，在let声明前使用这个变量就会报错，也就是只能先声明再使用，这种语法也称为暂时性死域。如下代码：本文多数转自于该博客https://www.cnblogs.com/echolun/p/10575676.html谢谢观看","comments":true,"categories":[],"tags":[]},{"title":"Hello World","date":"2020-05-03T16:12:12.115Z","path":"2020/05/04/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","comments":true,"categories":[],"tags":[]}]